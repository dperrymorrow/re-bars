<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>ReBars Docs</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.5.3/handlebars.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.19.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.19.0/components/prism-markup-templating.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.19.0/components/prism-handlebars.min.js"></script>
    <link rel="stylesheet" href="dist/docs.min.css">
    <script src="dist/re-bars.umd.min.js"></script>
  </head>

  <body>
    <main>
      <nav id="nav-container">
        <div class="logo">ReBars</div>

        <ul class="side-bar-nav">
            <li>
              <a href="#rebars">ReBars Introduction</a>
            </li>
            <li>
              <a href="#a-rebars-application">A ReBars Application</a>
                  <ul>
                      <li>
                        <a href="#getting-started">Getting Started</a>
                      </li>
                      <li>
                        <a href="#handlebars">Handlebars</a>
                      </li>
                      <li>
                        <a href="#data">Data</a>
                      </li>
                      <li>
                        <a href="#watch-methods">Watch Methods</a>
                      </li>
                      <li>
                        <a href="#helpers">Helpers</a>
                      </li>
                      <li>
                        <a href="#methods">Methods</a>
                      </li>
                      <li>
                        <a href="#partials">Partials</a>
                      </li>
                  </ul>
            </li>
            <li>
              <a href="#rebars-built-in-helpers">ReBars Helpers</a>
                  <ul>
                      <li>
                        <a href="#the-watch-helper">watch (re-rendering)</a>
                      </li>
                      <li>
                        <a href="#the-on-helper">on (event handling)</a>
                      </li>
                      <li>
                        <a href="#the-ref-helper">ref (element reference)</a>
                      </li>
                  </ul>
            </li>
            <li>
              <a href="#examples">Examples</a>
                  <ul>
                      <li>
                        <a href="#todo-list-simple">Simple</a>
                      </li>
                      <li>
                        <a href="#todo-list-advanced">Advanced</a>
                      </li>
                  </ul>
            </li>
        </ul>
      </nav>

      <section>
        <article class="content">
            <article class="page main" data-anchor="#rebars">
              <h1 id="the-problem">The Problem...</h1>
<p>Writing Javascript for the browser used to be simple. You wrote your code, and that same code ran in the browser. <strong>Your</strong> code is what was running in your application. You spent your time writing Javascript, not configuring tools.</p>
<p>Things have changed. <em>Modern</em> Javascript development requires rediculous amounts of tooling and setup. Webpack, JSX, Virtual DOM, Babel, CLI bolierplates, component loaders, Style extractors, concatenators and on and on. Have you looked in your <code>node_modules</code> directory recently? Have you ever seen the filesize of your <em>built</em> app and wondered WTF is all that?</p>
<p>The thing is, <strong>WE DON&#39;T NEED THIS ANYMORE</strong>. Evergreen browsers support the features we want that we have been Babeling and polyfilling in order to use. <a href="https://caniuse.com/#feat=es6">ES6</a> brought us Promises, Modules, Classes, Template Literals, Arrow Functions, Let and Const, Default Parameters, Generators, Destructuring Assignment, Rest &amp; Spread, Map/Set &amp; WeakMap/WeakSet and many more. All the things we have been waiting for It&#39;s all there!</p>
<p>So why are we still using build steps and mangling <strong>our</strong> beautiful code back to the stone age?</p>
<h2 id="rebars"><a href="#rebars">ReBars</a></h2>
<blockquote>
<p>ReBars is around 2.8k gzipped and has no dependancies other than Handlebars!</p>
</blockquote>
<p>ReBars started with the idea of so what do I <em>actually</em> need from a Javascript framework?</p>
<ul>
<li>a templating language <em>(Handlebars)</em></li>
<li>re-render DOM elements on data change</li>
<li>manage your event handling and scope</li>
</ul>
<p>ReBars re-renders tiny pieces of your application on change. You are in control of what re-renders and when. There is no Virtual DOM, no JSX, no pre-compiling. <strong>Your</strong> code runs on <strong>your</strong> app.</p>
<p>ReBars keeps your DOM in sync with your data using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>, and gets out of your way. You can get back to just writing Javascript.</p>
<p>ReBars is just a Handlebars instance with helpers added. The main one being a <a href="#the-watch-helper">watch</a> block helper that lets you tell ReBars what and when to re-render.</p>
<blockquote>
<p>If you have used Handlebars, you already know ReBars</p>
</blockquote>
<div class="example demo-app" example-target="ForDocsCounter">
  <!-- example ForDocsCounter gets rendered here... -->
</div>

<script type="module">
  import ForDocsCounter from "./examples/for-docs/counter.js";
  ReBars.app(ForDocsCounter).render("[example-target='ForDocsCounter']")
</script>

<pre><code class="language-javascript">export default {
  template: /*html*/ `
    &lt;strong&gt;
      Button have been clicked
      {{#watch}}
        {{ clicked }}
      {{/watch}}
      times
    &lt;/strong&gt;

    &lt;button {{ on click=&quot;step&quot; }}&gt;Click Me&lt;/button&gt;
  `,

  data: { clicked: 0 },

  methods: {
    step() {
      this.clicked++;
    },
  },
};
</code></pre>

            </article>
            <article class="page main" data-anchor="#a-rebars-application">
              <h1 id="a-rebars-application">A ReBars Application</h1>
<p>A ReBars application is a Handlebars template rendered to a specified DOM element. You can event have more than one app on a page if you desire.</p>

                <article class="page sub" data-anchor="#getting-started">
                  <h2 id="getting-started">Getting Started</h2>
<blockquote>
<p>You will need Handlebars in order to use ReBars. You can install it from NPM or use a CDN.</p>
</blockquote>
<pre><code class="language-html">&lt;!-- Handlebars from CDN ---&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.min.js&quot;&gt;&lt;/script&gt;
&lt;!-- ReBars from CDN ---&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/re-bars@latest/dist/index.umd.min.js&quot;&gt;&lt;/script&gt;</code></pre>
<p>Or using NPM</p>
<pre><code class="language-shell">npm i --save-dev handlebars re-bars</code></pre>
<pre><code class="language-javascript">import Handlebars from &quot;handlebars&quot;;
import ReBars from &quot;re-bars&quot;;</code></pre>
<h3 id="creating-an-application"><a href="#creating-an-application">Creating an Application</a></h3>
<p>To create an app, invoke the <code>Rebars.app</code> function with an Object describing your application. <em>(We will talk more about thes items in a sec)</em>.</p>
<pre><code class="language-javascript">{
  Handlebars // Optional, Handlebars source, defaults to window.Handlebars
  template: ``, // The Handlebars template string
  data: {}, // data passed to your template
  helpers: {}, // Hanlebars helpers to add
  partials: {}, // Hanlebars partials to register
  trace: true, // If true logs changes and re-renders to the console
}</code></pre>
<p>This will return an Object containing</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>instance</td>
<td>Object</td>
<td>the Handlebars instance the app is using</td>
</tr>
<tr>
<td>render</td>
<td>Function</td>
<td>the function to render the app</td>
</tr>
</tbody></table>
<h3 id="the-render-function"><a href="#the-render-function">The Render Function</a></h3>
<p>You then call <code>render</code> passing in the selector for a target element to render to.</p>
<pre><code class="language-javascript">const app = ReBars.app(...your app definition);
app.render(&quot;#my-app&quot;);</code></pre>

                </article>
                <article class="page sub" data-anchor="#handlebars">
                  <h2 id="handlebars">Handlebars</h2>
<p>If you would like use Handlebars from a source other than <code>window</code>, you can pass your instance of Handlebars to the <code>ReBars.app</code> function. This can be helpful for test setup.</p>
<pre><code class="language-javascript">import Handlebars from &quot;somewhere&quot;;
ReBars.app({
  Handlebars,
  ...
});</code></pre>

                </article>
                <article class="page sub" data-anchor="#data">
                  <h2 id="data">Data</h2>
<p>The data object you provide to your ReBars application is the core of what makes ReBars great.</p>
<p>Your data object is what is passed to your Handlebars template on render, and what is watched for changes with the <a href="#the-watch-helper">watch</a>, and triggers re-renders.</p>
<pre><code class="language-javascript">{
  data: {
    name: {
      first: &quot;David&quot;,
      last: &quot;Morrow&quot;
    }
  }
}</code></pre>
<blockquote>
<p>You don&#39;t have to do anything special for ReBars to observe all changes to your data Object. In fact ReBar&#39;s observer is native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a></p>
</blockquote>
<h3 id="methods-in-your-data">Methods in your data</h3>
<p>You can also return a method as a value from your data. This is a simple yet powerful feture that lets you return calculations based off your data&#39;s state at that point in time. You can even define methods at runtime, or nest them deeply within your data Object.</p>
<div class="example demo-app" example-target="ForDocsDataMethod">
  <!-- example ForDocsDataMethod gets rendered here... -->
</div>

<script type="module">
  import ForDocsDataMethod from "./examples/for-docs/data-method.js";
  ReBars.app(ForDocsDataMethod).render("[example-target='ForDocsDataMethod']")
</script>

<pre><code class="language-javascript">export default {
  template: /*html*/ `
    {{#watch &quot;friends.length&quot; tag=&quot;h3&quot; }}
      my friends: {{ allMyFriends }}
    {{/watch}}

    &lt;input type=&quot;text&quot; {{ ref &quot;input&quot; }}&gt;
    &lt;button {{ on click=&quot;add&quot; }}&gt;Add&lt;/button&gt;
  `,

  data: {
    allMyFriends() {
      return this.friends.join(&quot;, &quot;);
    },

    friends: [&quot;Mike&quot;, &quot;David&quot;, &quot;Todd&quot;, &quot;Keith&quot;],
  },

  methods: {
    add({ rootData, $refs }) {
      const $input = $refs().input;
      rootData.friends.push($input.value);
      $input.value = &quot;&quot;;
    },
  },
};
</code></pre>
<p>Any method defined in your data Object will be scoped to your data object <code>this</code></p>
<blockquote>
<p>You <strong>cannot</strong> however <code>watch</code> a method from your data. You would need to watch the item or items in your data that the method relies on its computation for.</p>
</blockquote>

                </article>
                <article class="page sub" data-anchor="#watch-methods">
                  <h2 id="watch-methods">Watch Methods</h2>

                </article>
                <article class="page sub" data-anchor="#helpers">
                  <h2 id="helpers">Helpers</h2>
<p>If you would like to add helpers to your app you can pass a helpers Object to the <code>ReBars.app</code> function.</p>
<pre><code class="language-javascript">ReBars.app({
  helpers: {} // your custom helpers
  ...
});</code></pre>
<p>The helpers operate just as any other Handlebars helper you would add. <code>this</code> is the scope of the render block. <a href="https://handlebarsjs.com/guide/#custom-helpers">more about Handlebars helpers here</a></p>
<p>In the example below, you would then be able to use your <code>isChecked</code> helper anywhere in your application.</p>
<div class="example demo-app" example-target="ForDocsCustomHelper">
  <!-- example ForDocsCustomHelper gets rendered here... -->
</div>

<script type="module">
  import ForDocsCustomHelper from "./examples/for-docs/custom-helper.js";
  ReBars.app(ForDocsCustomHelper).render("[example-target='ForDocsCustomHelper']")
</script>

<pre><code class="language-javascript">export default {
  template: /*html*/ `
    &lt;label&gt;
      {{#watch}}
        &lt;input type=&quot;checkbox&quot; {{ isChecked }} {{ on input=&quot;toggle&quot; }}&gt;
      {{/watch}}
      Is On
    &lt;/label&gt;
    &lt;button {{ on click=&quot;toggle&quot; }}&gt;Toggle&lt;/button&gt;
  `,

  data: {
    isOn: false,
  },

  methods: {
    toggle() {
      this.isOn = !this.isOn;
    },
  },

  helpers: {
    isChecked() {
      if (this.isOn) return &quot;checked&quot;;
    },
  },
};
</code></pre>
<p>ReBars simply registers these helpers for you to the Handlebars instance of your app. Should you want to register more helpers yourself instead of defining them in your app definition, you can do so using the instance returned from creating your app. It&#39;s the same thing.</p>
<pre><code class="language-javascript">const { instance } = ReBars.app(...);
instance.registerHelper(&quot;myCustomHelper&quot;, function () {
  // helper code...
})</code></pre>

                </article>
                <article class="page sub" data-anchor="#methods">
                  <h2 id="methods">Methods</h2>
<p>Methods define functions that can be called from event handlers, <a href="#the-on-helper">see on helper</a> or can be called from another method in your application. This allows you to share code, and prevent redundant declarations.</p>
<p>When a method is triggerd, it is called with the current scope of the template from where it was called <code>this</code>, similar to how Handlebars helpers are called with <code>this</code> as the scope of which the helper was triggered.</p>
<p>The first param when invoked is an object containing the following.</p>
<pre><code class="language-javascript">methods: {
  myMethod({ event, $app, rootData, $refs, $nextTick, methods}) {
    ...
  }
}</code></pre>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>event</code></td>
<td><code>Event Object</code></td>
<td>the event Object triggered from the UI interaction MouseEvent ect.</td>
</tr>
<tr>
<td><code>$app</code></td>
<td><code>Element</code></td>
<td>the element that the app is rendered to.</td>
</tr>
<tr>
<td><code>rootData</code></td>
<td><code>Object</code></td>
<td>the data at the root of your application.</td>
</tr>
<tr>
<td><code>$refs</code></td>
<td><code>Function</code></td>
<td><code>$refs()</code> returns all the elements in your application that have been marked with a <a href="#the-ref-helper">ref</a></td>
</tr>
<tr>
<td><code>$nextTick</code></td>
<td><code>Function</code></td>
<td>returns a promose when called. Allows you to wait until after the next render to preform an action on the DOM</td>
</tr>
<tr>
<td><code>methods</code></td>
<td><code>Object</code></td>
<td>the methods defined in your app. If called, they will be called with the same scope.</td>
</tr>
</tbody></table>
<blockquote>
<p>If you call a method from another method. The scope remains the same. <em>(the context in the template where the call originated)</em></p>
</blockquote>
<p>Here is an example of chaining methods from within a ReBars appliction.</p>
<div class="example demo-app" example-target="ForDocsMethods">
  <!-- example ForDocsMethods gets rendered here... -->
</div>

<script type="module">
  import ForDocsMethods from "./examples/for-docs/methods.js";
  ReBars.app(ForDocsMethods).render("[example-target='ForDocsMethods']")
</script>

<pre><code class="language-javascript">export default {
  template: /*html*/ `
    {{#each foods as | food | }}
      &lt;button {{ on click=&quot;isFavorite&quot; }}&gt;{{ food }}&lt;/button&gt;
    {{/each}}

    {{#watch}}
      {{ favorite }}
    {{/watch}}
  `,

  data: {
    favorite: null,
    foods: [&quot;pizza&quot;, &quot;cake&quot;, &quot;donuts&quot;],
  },

  methods: {
    display({ rootData }) {
      rootData.favorite = `${this.toUpperCase()}!! is my favorite food`;
    },

    isFavorite({ event, $refs, $nextTick, rootData, methods }) {
      methods.display();
    },
  },
};
</code></pre>

                </article>
                <article class="page sub" data-anchor="#partials">
                  <h2 id="partials">Partials</h2>

                </article>
            </article>
            <article class="page main" data-anchor="#rebars-built-in-helpers">
              <h1 id="rebars-built-in-helpers">ReBars built in helpers</h1>
<p>ReBars consists of a few very powerful Handlebars helpers. Of course you can add your own to extend even futher, but the following is what you get on install.</p>

                <article class="page sub" data-anchor="#the-watch-helper">
                  <h2 id="the-watch-helper">The watch helper</h2>
<p>The watch helper tells ReBars to re-render this block on change of the item you pass in as the second parameter.</p>
<p>Watch allows you to re-render a block of your template on change.
Watch takes an <em>optional</em> arguments of what properties to watch. The arguments can be string or a regular expression. You may aslo as many as you like. When any change, the block will re-render.</p>
<p>In our explanation below, we will be referring to this data set.</p>
<pre><code class="language-javascript">{
  data: {
    hobby: &quot;running&quot;,
    name: {
      first: &quot;David&quot;,
      last: &quot;Morrow&quot;
    },
    friends: [
      { name: &quot;Joe&quot;, hobby: &quot;boxing&quot; },
      { name: &quot;Fred&quot;, hobby: &quot;cooking&quot; }
    ]
  }
}</code></pre>
<pre><code class="language-html">{{#watch}}
  My name is {{ name.first }} {{ name.last }}.
{{/watch}}</code></pre>
<p>The above omits the what to watch. In this situation, ReBars will pre-render the block, and captures any references used. It would evaluate to the same as.</p>
<pre><code class="language-html">{{#watch &quot;name.first&quot; &quot;name.last&quot; }}</code></pre>
<blockquote>
<p>If you are unsure what to watch, ReBars traces out changes to the console when you pass <code>trace: true</code> to your application.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Argument Example</th>
<th>re-renders when</th>
</tr>
</thead>
<tbody><tr>
<td><code>{{#watch &quot;name(*.)&quot; }}</code></td>
<td>on any change to name Object</td>
</tr>
<tr>
<td><code>{{#watch &quot;name.first&quot; }}</code></td>
<td>on changes to the string <code>name.first</code></td>
</tr>
<tr>
<td><code>{{#watch &quot;name(*.)&quot; &quot;friends(*.)&quot; }}</code></td>
<td>any change to name or friends</td>
</tr>
<tr>
<td><code>{{#watch &quot;friends[1].hobby&quot; }}</code></td>
<td>on changes to friends index 1 hobby change</td>
</tr>
<tr>
<td><code>{{#watch &quot;friends(*.)hobby&quot; }}</code></td>
<td>on change to any friend&#39;s hobby change</td>
</tr>
</tbody></table>
<blockquote>
<p>You can use any regular expression you would like. The examples above use <code>(*.)</code> which equates to any character.</p>
</blockquote>
<h3 id="watch-element-wrappers"><a href="#watch-element-wrappers">Watch Element wrappers</a></h3>
<p>Each <code>{{#watch}}</code> block gets wrapped by default in a <code>&lt;span&gt;</code> tag with attributes marking what outlet this represents. Sometimes this can get in the way of styling your layouts.</p>
<p>As a solution you can add a tag, class id, any attribute you want to the watch block.</p>
<blockquote>
<p>Remember, Handlebars helper arguments must have the params before <code>key=&quot;value&quot;</code> arguments <code>{{#watch &quot;name.first&quot; tag=&quot;h1&quot; }}</code></p>
</blockquote>
<div class="example demo-app" example-target="ForDocsWatcherTag">
  <!-- example ForDocsWatcherTag gets rendered here... -->
</div>

<script type="module">
  import ForDocsWatcherTag from "./examples/for-docs/watcher-tag.js";
  ReBars.app(ForDocsWatcherTag).render("[example-target='ForDocsWatcherTag']")
</script>

<pre><code class="language-javascript">export default {
  template: /*html*/ `
    {{#watch &quot;name&quot; tag=&quot;h3&quot;}}
      {{ name }}
    {{/watch}}

    &lt;input type=&quot;text&quot; value=&quot;{{ name }}&quot; {{ on input=&quot;saveName&quot; }}&gt;
  `,
  data: {
    name: &quot;David&quot;,
  },
  methods: {
    saveName({ event }) {
      this.name = event.target.value;
    },
  },
};
</code></pre>
<h3 id="watching-arrays"><a href="#watching-arrays">Watching Arrays</a></h3>
<p><code>{{#watch}}</code> can be used on an <code>Array</code> as well. But if one item in the Array changes, you don&#39;t want to re-render the entire block. That could have performance implications. Instead, ReBars will only update changed items in the block if every element has a <a href="#the-ref-helper">reference</a></p>
<blockquote>
<p>By using the ref helper <code>{{ ref &quot;somethingUnique&quot; }}</code> on each item, it enables ReBars to only re-render the changed items. <em>Each ref must be unique</em> such as a pKey from the database or such.</p>
</blockquote>
<pre><code class="language-html">{{#watch &quot;friends(*.)&quot; tag=&quot;ul&quot; }}
  {{#each friends as | friend | }}
    &lt;li {{ ref friend.name }}&gt;
      {{ friend.name }} likes to {{ friend.hobby }}
    &lt;/li&gt;
  {{/each}}
{{/watch}}</code></pre>

                </article>
                <article class="page sub" data-anchor="#the-on-helper">
                  <h2 id="the-on-helper">The on helper</h2>
<p>This allows you to bind your component&#39;s methods to events in your template. The method will be called with the first param an Object as described <a href="#methods">above</a> and any additional params that are passed to the helper.</p>
<p>The method will be called with <code>this</code> <em>(scope)</em> as the context in the template from where the on helper was called</p>
<pre><code class="language-html">&lt;button {{ on &quot;yes&quot; click=&quot;save&quot; }}&gt;Save&lt;/button&gt;</code></pre>
<pre><code class="language-javascript">methods: {
  save(context, arg) {
    console.log(arg);
    // yes
  }
}</code></pre>
<blockquote>
<p>Remember Handlebars requires params to be first, and then <code>key=&quot;val&quot;</code> arguments second</p>
</blockquote>
<p>You can also call multiple events on one invocation of the on helpers. For example.</p>
<pre><code class="language-html">&lt;input {{ on focus=&quot;focused&quot; blur=&quot;blurred&quot; input=&quot;inputChange&quot; &gt;</code></pre>

                </article>
                <article class="page sub" data-anchor="#the-ref-helper">
                  <h2 id="ref-element-reference">ref (element reference)</h2>

                </article>
            </article>
            <article class="page main" data-anchor="#examples">
              <h1 id="examples">Examples</h1>
<p>Here you can get a better idea of how one would build a small application with ReBars. The entire source code for the examples is shown below the functioning ReBars app.</p>

                <article class="page sub" data-anchor="#todo-list-simple">
                  <h2 id="todo-list-simple">Todo List Simple</h2>
<p>A simple, one component application that tracks todos. You can view source code on <a href="https://github.com/dperrymorrow/re-bars/blob/master/docs/examples/app.js">Github</a></p>
<div class="example demo-app" example-target="App">
  <!-- example App gets rendered here... -->
</div>

<script type="module">
  import App from "./examples/app.js";
  ReBars.app(App).render("[example-target='App']")
</script>

<pre><code class="language-javascript">export default {
  template: /*html*/ `
  &lt;div&gt;
    &lt;div class=&quot;header-container&quot;&gt;
      &lt;h1&gt;
        {{#watch}}
          &lt;span&gt;{{ header.title }}&lt;/span&gt;
          &lt;small&gt;{{ header.description }}&lt;/small&gt;
        {{/watch}}
      &lt;/h1&gt;

      &lt;label&gt;
        Title:
        &lt;input
          type=&quot;text&quot;
          value=&quot;{{ header.title }}&quot;
          {{ on input=&quot;updateTitle&quot; }}
        /&gt;
      &lt;/label&gt;

      &lt;label&gt;
        Description:
        &lt;input
          type=&quot;text&quot;
          value=&quot;{{ header.description }}&quot;
          {{ on input=&quot;updateDescription&quot; }}
        /&gt;
      &lt;/label&gt;
    &lt;/div&gt;

    &lt;ul class=&quot;simple&quot;&gt;
      {{#watch &quot;todos(.*)&quot; }}
        {{#each todos }}
          &lt;li {{ ref id }}&gt;
            &lt;div class=&quot;todo&quot;&gt;
              &lt;label&gt;
                &lt;input
                  type=&quot;checkbox&quot;
                  {{ on click=&quot;toggleDone&quot; }}
                  {{ isChecked }}
                /&gt;
                {{#if done }}
                  &lt;s&gt;{{ name }}&lt;/s&gt;
                {{else}}
                  &lt;strong&gt;{{ name }}&lt;/strong&gt;
                {{/if}}
              &lt;/label&gt;

              &lt;div class=&quot;actions&quot;&gt;
                &lt;button {{ on click=&quot;deleteTodo&quot; }}&gt;
                  delete
                &lt;/button&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/li&gt;
        {{/each}}
      {{/watch}}
    &lt;/ul&gt;

    {{#watch}}
      {{#if adding }}
        &lt;form&gt;
          &lt;input type=&quot;text&quot; {{ ref &quot;newName&quot; }} placeholder=&quot;the new todo&quot; /&gt;
          &lt;button {{ on click=&quot;addItem&quot; }}&gt;Add todo&lt;/button&gt;
          &lt;button {{ on click=&quot;toggleCreate&quot; }}&gt;Cancel&lt;/button&gt;
        &lt;/form&gt;
      {{else}}
        &lt;button {{ on click=&quot;toggleCreate&quot; }}&gt;Add another&lt;/button&gt;
      {{/if}}
    {{/watch}}
  &lt;/div&gt;
  `,

  trace: true,

  data: {
    adding: false,
    header: {
      title: &quot;Todos&quot;,
      description: &quot;some things that need done&quot;,
    },
    todos: [
      {
        done: false,
        name: &quot;Grocery Shopping&quot;,
        id: 22,
      },
      {
        done: true,
        name: &quot;Paint the House&quot;,
        id: 44,
      },
    ],
  },

  helpers: {
    isChecked() {
      return this.done ? &quot;checked&quot; : &quot;&quot;;
    },
  },

  methods: {
    updateTitle({ event }) {
      this.header.title = event.target.value;
    },

    updateDescription({ event }) {
      this.header.description = event.target.value;
    },

    addItem({ $refs, event }) {
      event.preventDefault();
      const $input = $refs().newName;

      this.todos.push({
        id: new Date().getTime(),
        done: false,
        name: $input.value,
      });

      $input.value = &quot;&quot;;
    },

    findTodo({ rootData }, id) {
      return rootData.todos.find(item =&gt; item.id === parseInt(id));
    },

    deleteTodo({ rootData }) {
      const index = rootData.todos.findIndex(t =&gt; t.id === this.id);
      rootData.todos.splice(index, 1);
    },

    toggleDone({ event, methods }) {
      const todo = methods.findTodo(this.id);
      todo.done = !this.done;
    },

    toggleCreate({ event }) {
      event.preventDefault();
      this.adding = !this.adding;
    },
  },
};
</code></pre>

                </article>
                <article class="page sub" data-anchor="#todo-list-advanced">
                  <h2 id="todo-list-advanced">Todo List Advanced</h2>
<p>Same concept, a little more advanced using partials, some sorting and filtering. You can view the full app source code on <a href="https://github.com/dperrymorrow/re-bars/tree/master/docs/examples/advanced">Github</a></p>
<div class="example demo-app" example-target="AdvancedApp">
  <!-- example AdvancedApp gets rendered here... -->
</div>

<script type="module">
  import AdvancedApp from "./examples/advanced/app.js";
  ReBars.app(AdvancedApp).render("[example-target='AdvancedApp']")
</script>

<pre><code class="language-javascript">import Add from &quot;./add.js&quot;;
import Todo from &quot;./todo.js&quot;;
import Filters from &quot;./filters.js&quot;;

const { localStorage } = window;
const storageKey = &quot;rebars-todo&quot;;
const store = localStorage.getItem(storageKey) || &quot;{}&quot;;
const { todos, header } = JSON.parse(store);

export default {
  template: /*html*/ `
    &lt;div class=&quot;header-container&quot;&gt;
      {{#watch tag=&quot;h1&quot; }}
        &lt;span&gt;{{ header.title }}&lt;/span&gt;
        &lt;small&gt;{{ header.description }}&lt;/small&gt;
      {{/watch}}

      &lt;label&gt;
        Title:
        &lt;input type=&quot;text&quot; value=&quot;{{ header.title }}&quot; {{ on input=&quot;updateTitle&quot; }} /&gt;
      &lt;/label&gt;

      &lt;label&gt;
        Description:
        &lt;input type=&quot;text&quot; value=&quot;{{ header.description }}&quot; {{ on input=&quot;updateDescription&quot; }} /&gt;
      &lt;/label&gt;
    &lt;/div&gt;

    {{&gt; Filters }}

    {{#watch &quot;filters(.*)&quot; &quot;todos(.*)&quot; tag=&quot;ul&quot;}}
      {{#each filteredTodos as | todo | }}
        {{&gt; Todo todo=todo }}
      {{/each}}
    {{/watch}}

    {{&gt; Add }}
  `,

  trace: true,

  watch: {
    &quot;(.*)&quot;() {
      localStorage.setItem(storageKey, JSON.stringify(this.data));
    },
  },

  data: {
    header: header || {
      title: &quot;ReBars Todos&quot;,
      description: &quot;Some things that need done&quot;,
    },

    todos: todos || [
      {
        done: false,
        name: &quot;Wash the car&quot;,
        updated: &quot;3/1/2020, 12:37:10 PM&quot;,
        id: 21,
      },
      {
        done: true,
        name: &quot;Shopping for groceries&quot;,
        updated: &quot;2/27/2020, 2:37:10 PM&quot;,
        id: 22,
      },

      {
        done: false,
        name: &quot;Code some Javascript&quot;,
        updated: &quot;1/27/2020, 9:37:10 AM&quot;,
        id: 23,
      },

      {
        done: true,
        name: &quot;Go for a run&quot;,
        updated: &quot;1/15/2020, 10:37:10 PM&quot;,
        id: 24,
      },
    ],
  },

  partials: {
    Todo,
    Filters,
    Add,
  },

  methods: {
    updateTitle({ event, methods }) {
      this.header.title = event.target.value;
    },

    updateDescription({ event, methods }) {
      this.header.description = event.target.value;
    },
  },
};
</code></pre>

                </article>
            </article>
        </article>
      </section>
    </main>

    <script>
      const src = (window.location.host.includes("localhost")) ? "_src/docs.js" : "dist/docs.min.js";
      const $script = document.createElement("script");
      $script.src = src
      document.body.append($script);
    </script>

  </body>
</html>
