<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>ReBars Docs: Introduction</title>
    <link rel="stylesheet" href="css/index.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.5.3/handlebars.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/prismjs@1.19.0/prism.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/prismjs@1.19.0/components/prism-markup-templating.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/prismjs@1.19.0/components/prism-handlebars.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/marked/0.8.1/marked.min.js"></script>
  </head>

  <body>

    <main>
      <nav id="nav-container">

        <div class="logo">ReBars</div>


      </nav>
      <section>
        <div class="content">
          <div class="markdown-content">
            <h1>ReBars built in helpers</h1><p>ReBars comes with a few very powerfull helpers. Of course you can add your own to any component, or at the application level just as you would with any Handlebars application.</p>
<h2>The {{#watch}} helper</h2><p>The watch helper tells ReBars to re-render this block on change of the item you pass in as the second parameter.</p>
<pre><code class="language-javascript">data() {
  return {
    hobby: &quot;running&quot;,
    name: {
      first: &quot;David&quot;,
      last: &quot;Morrow&quot;
    },
    friends: [
      { name: &quot;Joe&quot;, hobby: &quot;boxing&quot; },
      { name: &quot;Fred&quot;, hobby: &quot;cooking&quot; }
    ]
  }
}</code></pre>
<p>Watch allows you to re-render a block of your template on change.
Watch takes an argument of what property to watch. The argument can be a string or an object.</p>
<pre><code class="language-html">{{#watch name }}
  My name is {{ name.first }} {{ name.last }}.
{{/watch}}</code></pre>
<p>Anytime <code>name</code> is changed the block would be re-rendered with the updated data.</p>
<blockquote>
<p>If the item you are watching is a primitive such as a <code>String</code>, or <code>Number</code>. You will need to use a string as the argument.</p>
</blockquote>
<ul>
<li><code>{{#watch name }}</code> this will watch all keys on Object <code>name</code></li>
<li><code>{{#watch &quot;name.*&quot; }}</code> this is the string equvilent of the above</li>
<li><code>{{#watch &quot;name.first&quot; }}</code> will only watch for changes to <code>name.first</code></li>
<li><code>{{#watch &quot;name.*,hobby&quot; }}</code> will watch for any change to name or hobby</li>
<li><code>{{#watch &quot;friends.*.hobby&quot; }}</code> will watch for any friend index hobby change</li>
</ul>
<h3>Watch Element wrappers</h3><p>Each <code>{{watch}}</code> block gets wrapped in a span with an id which is stored to remember what outlet to re-render on change. Sometimes this can get in the way of styling your layouts.</p>
<p>As a solution you can add a tag, class id, any attribute you want to the watch block.</p>
<pre><code class="language-html">{{#watch name tag=&quot;p&quot; class=&quot;intro&quot; id=&quot;intro-p&quot; }}
  {{ name.first }} {{ name.last }}
{{/watch}}

&lt;!-- outputs --&gt;
&lt;p class=&quot;intro&quot; id=&quot;intro-p&quot; data-rbs-watch=&quot;rbs4&quot;&gt;
  David Morrow
&lt;/p&gt;</code></pre>
<h3>Watching Arrays</h3><p><code>{{#watch}}</code> can be used on an <code>Array</code> as well.</p>
<blockquote>
<p>Be sure to add a <code>{{ ref }}</code> to each item enabling ReBars to only re-render changed items. <em>Each ref must be unique</em></p>
</blockquote>
<pre><code class="language-html">&lt;ul&gt;
  {{#watch friends }}
    {{#each friends as | friend | }}
      &lt;li {{ ref friend.name }}&gt;
        {{ friend.name }} likes to {{ friend.hobby }}
      &lt;/li&gt;
    {{/each}}
  {{/watch}}
&lt;/ul&gt;</code></pre>
<p>If you are watching inside a loop, you can target the specific object and key by passing further arguments. The example below will only trigger a re-render on that <code>friend.name</code> <em>(the item in the loop)</em> change</p>
<pre><code class="language-html">&lt;ul&gt;
  {{#each friends as | friend | }}
    &lt;li&gt;
      {{#watch friend &quot;name&quot; }}
        {{ friend.name }}
      {{/watch}}
    &lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</code></pre>
<h2>The {{ref}} helper</h2><p>ReBars comes with a <code>{{ref}}</code> helper built in. This gives you the ability to save a reference to an element. This also gives a key for Array loop items so that the Array can be patched instead of re-rendered entirely.</p>
<ul>
<li>takes one param, the <code>String</code> for the reference</li>
</ul>
<blockquote>
<p>The ref helper is also needed on any input or other elements that need focused restored after a re-render.</p>
</blockquote>
<pre><code class="language-html">&lt;div&gt;
  &lt;h1 {{ ref &quot;header&quot; }}&gt;Header&lt;/h1&gt;
&lt;/div&gt;</code></pre>
<p>inside of a method, you can reference any ref by using the <code>$refs()</code> function from a method in your component.</p>
<pre><code class="language-javascript">methods: {
  save() {
    this.$refs().header;
    // returns the &lt;h1&gt; element
  }
}</code></pre>
<h2>The {{bound}} helper</h2><p>The <code>{{bound}</code> helper is used on input elements such as <code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code> elements. The parameter passed will sync the value attribute to the value, and on <code>input</code> event update the value.</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; {{ bound &quot;name.first&quot; }} /&gt;</code></pre>
<p>an item that is bound will automatically get a ref added as the path of the property. this is used for resetting focus and cursor position after a re-render. If you have more than one item with the same bound property, you may need to add another reference</p>
<p>You can pass in a ref as a prop to this helper should you need something more specific.</p>
<pre><code class="language-html">&lt;input type=&quot;text&quot; {{ bound &quot;name.first&quot; ref=&quot;firstName&quot; }} /&gt;</code></pre>
<h2>The {{method}} helper</h2><p>This allows you to bind your component&#39;s methods to events in your template.</p>
<pre><code class="language-html">&lt;button {{ method &quot;save:click&quot; &quot;param1&quot; &quot;param2&quot; }}&gt;Save&lt;/button&gt;</code></pre>
<pre><code class="language-javascript">methods: {
  save(event, arg1, arg1) {
    console.log(arg1, arg1);
    // param1 param2
  }
}</code></pre>
<blockquote>
<p>You method, when invoked, the first argument will always be the event, followed by any additional parameters. Params must be primiteve and not full Objects or Arrays.</p>
</blockquote>
<ul>
<li>the first param is the methodName separated by <code>:eventType</code>, if none is specified <code>click</code> will be the event</li>
<li>you can add as many other parameters as you would like to your method call</li>
</ul>
<h2>The {{component}} helper</h2><p>This allows you to render child components from withing the compnent you are in. It takes one parameter, the name of the component to render. This will render a registered component to the DOM of the parent component.</p>
<blockquote>
<p>The &quot;name&quot; of the component is the name property in the component&#39;s definition. Not the name you imported it as.</p>
</blockquote>
<pre><code class="language-html">{{ component &quot;myComponentName&quot; }}</code></pre>
<p>You can pass props to the component. Any props sent in will be merged with the component&#39;s data. If a prop is a method, it will be merged into the child component&#39;s methods. The &quot;friend&quot; component will have friend defined in it&#39;s data.</p>
<pre><code class="language-html">&lt;ul&gt;
  {{#each friends as | friend | }}
    {{ component &quot;friend&quot; friend=friend }}
  {{/each}}
&lt;/ul&gt;</code></pre>
<h3>Passing Methods as props</h3><p>You can pass methods to child components as well, they will be merged into the child&#39;s methods.</p>
<p><strong>Parent component:</strong></p>
<pre><code class="language-html">&lt;ul&gt;
  {{#watch friends }}
    {{#each friends as | friend | }}
      {{
        component &quot;friend&quot;
        friend=friend
        index=@index
        deleteFriend=$methods.deleteFriend
      }}
    {{/each}}
  {{/watch}}
&lt;/ul&gt;</code></pre>
<pre><code class="language-javascript">methods: {
  deleteFriend(event, index) {
    this.friends.splice(index, 1)
  },
}</code></pre>
<p><strong>Child component:</strong></p>
<pre><code class="language-html">&lt;button {{ method &quot;remove&quot; }}&gt;Delete Joe&lt;/button&gt;</code></pre>
<pre><code class="language-javascript">methods: {
  remove(event, name) {
    this.$props.deleteFriend(this.$props.index)
  }
}</code></pre>
<p>on clicking of the button, the friend would be deleted in the parent. Any watch blocks watching the <code>friends.*</code> or <code>friend[index]</code> would be re-rendered.</p>
<h2>The {{debug}} helper</h2><p>this helper allows you to view the state of your data in the template.</p>
<p>To output all data for your template, use the Handlebars <code>.</code> reference.</p>
<pre><code class="language-html">&lt;!-- full debug --&gt;
{{ debug . }}
&lt;!-- debug name object --&gt;
{{ debug name }}</code></pre>
          </div>
        </div>
      </section>
    </main>
    
    <script src="js/index.js"></script>
  </body>
</html>
