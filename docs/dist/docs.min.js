"use strict";const e={warn:"background: #484915; color: #ffffbe; padding: .1em; font-weight: normal;",log:"background: #324645; color:#c9faff; padding: .1em; font-weight: normal;"},t=(t,n,...o)=>{let a=n;if("object"==typeof o[0]&&"template"in o[0]&&"loc"in o[0]&&(a+=(({template:e,loc:t})=>{const n=e.split("\n").slice(t.start.line-1,t.end.line),o=Array(n[0].length-n[0].trim().length).join(" "),a=n.map(e=>e.replace(o,"     "));return a[0]=`>>>> ${a[0].trim()}`,`\n  template line: ${t.start.line}\n  ============================================\n  ${a.join("\n")}\n  `})(o[0]),o.splice(0,1)),!["warn","log"].includes(t))throw new Error(a);a="%c "+a+" ",window.ReBars&&window.ReBars.trace&&(o?(console.groupCollapsed(a,e[t]),o.forEach(console.log),console.groupEnd()):console.log(a,e[t]))};var n={warn:t.bind(null,"warn"),fail:t.bind(null,"throw"),log:t.bind(null,"log")};let o=1;var a={dom:{tagComponent(e,t,o){const a=this.getShadow(t),r=a.firstElementChild;if(!r)throw new Error("there was no root node. Components need a root element.");return["P"].includes(r.nodeName)&&n.fail(`${o}: <${r.nodeName.toLowerCase()}> cannot be a root element of for a component, try a <div>`),a.children.length>1&&n.fail(`${o}: multiple root nodes are not allowed for a component.`),r.dataset.rbsWatch&&n.fail(`${o}: cannot have a watch as the root node of a component`),r.dataset.rbsComp=e,a.innerHTML},recordState(e){const t=document.activeElement,n=t.getAttribute("ref");return e.contains(t)&&n?{ref:n,scrollTop:t.scrollTop,scrollLeft:t.scrollLeft,selectionStart:t.selectionStart}:null},restoreState(e,t){if(!t)return;const o=this.findRef(e,t.ref);if(o)if(Array.isArray(o))n.warn(`ref="${t.ref}" is used more than once. Focus cannot be restored. If using bind, add a ref="uniqeName" to each usage`,o);else{if(t.selectionStart){o.focus();const e="TEXTAREA"===o.tagName?t.selectionStart:t.selectionStart+1;o.setSelectionRange(e,e)}o.scrollTop=t.scrollTop,o.scrollLeft=t.scrollLeft}},findComponent:e=>document.querySelector(`[data-rbs-comp="${e}"]`),findRef:(e,t)=>e.getAttribute("ref")===t?e:e.querySelector(`[ref="${t}"]`),findRefs(e){const t=this.findComponent(e),n=Array.from(t.querySelectorAll("[ref]"));return t.getAttribute("ref")&&n.push(t),n.reduce((e,t)=>{const n=t.getAttribute("ref"),o=e[n];return e[n]=o?[o].concat(t):t,e},{})},findWatcher:e=>document.querySelector(`[data-rbs-watch="${e}"]`),propStr:e=>Object.entries(e).map(([e,t])=>`${e}="${t}"`).join(" "),wrapWatcher(e,t,n){const{tag:o,...a}={tag:"span",...n};return`<${o} ${this.propStr(a)} ${t.length?"":"style='display:none;'"} data-rbs-watch="${e}">${t}</${o}>`},getShadow(e){const t=document.createElement("div");return t.innerHTML=e,t}},stringify:(e,t=2)=>JSON.stringify(e,(e,t)=>"function"==typeof t?t+"":t,t),debounce(e,t=0,n=!1){let o=null;return function(){const a=n&&!o,r=()=>e.apply(this,arguments);clearTimeout(o),o=setTimeout(r,t),a&&r()}},isProp:e=>!("string"!=typeof e||!e.startsWith("$props"))||!("object"!=typeof e||!e.ReBarsPath.startsWith("$props")),shouldRender:(e,t)=>(Array.isArray(t)?t:[t]).some(t=>{if(e===t||".*"===t)return!0;const n=e.split(".");return t.split(".").every((e,t)=>e===n[t]||"*"===e)}),randomId:()=>`rbs${o++}`,getKey:(e,t)=>t.split(".").reduce((o,a)=>(a in o||n.fail(`${t} was not found in object`,e),o[a]),e),hasKey(e,t){if(t.includes("*"))return!0;try{return this.getKey(e,t),!0}catch(e){return!1}},setKey(e,t,o){const a=t.split(".");a.reduce((r,d,s)=>(d in r||n.fail(`${t} was not found in object!`,e),s+1===a.length&&(r[d]=o),r[d]),e)}},r={protectedKeys:["$_componentId","$props","$methods","$name","$parent"],listenerPrefix:"listen:"},d={create(e,t,o=!1){let d=[];const s=a.debounce(()=>{t(d),d=[]}),i=e=>{d.push(e),s(d)};const l=function e(t,o=[]){return new Proxy(t,{get:function(t,n){if("ReBarsPath"===n)return o.join(".");const a=Reflect.get(...arguments);return"function"==typeof a&&t.hasOwnProperty(n)?a.bind(l):r.protectedKeys.includes(o[0])?a:null!==a&&"object"==typeof a&&"methods"!==n?e(a,o.concat(n)):a},set:function(e,t){const a=Reflect.set(...arguments),d=o.concat(t).join(".");return r.protectedKeys.includes(o[0])?n.warn(`attempted to set a protected key "${d}". readOnly properties are ${r.protectedKeys}`):i(d),a},deleteProperty:function(e,t){const a=Reflect.deleteProperty(...arguments),d=o.concat(t).join(".");return r.protectedKeys.includes(o[0])||n.fail(`cannot delete protected key ${d}. readOnly properties are ${r.protectedKeys}`),i(d),a}})}(e);return l}},s={register({app:e,instance:t,components:o,helpers:r,template:s,methods:i,name:l}){Object.entries(r).forEach(([e,n])=>t.registerHelper(e,n)),t.registerHelper("isComponent",e=>Object.keys(o).includes(e)),t.registerHelper("component",(function(...e){const{hash:a,loc:r}=e.pop(),d=e[0];return o[d]||n.fail(`${l}: child component "${d}" is not registered`,{template:s,loc:r}),Object.entries(a).forEach(([e,t])=>{void 0===t&&n.fail(`${l}: passed "${e}" as undefined. If you really meant to, pass null instead.`,{template:s,loc:r})}),new t.SafeString(o[d].instance(a).render())})),t.registerHelper("debug",(e,{hash:o,data:r,loc:d})=>{void 0===e&&n.fail(`${l}: undefined passed to debug`,{template:s,loc:d});const i={class:"debug",...o};return new t.SafeString(`<pre ${a.dom.propStr(i)}>${a.stringify(e)}</pre>`)}),t.registerHelper("watch",(function(...o){const{fn:r,hash:i,data:c,loc:p}=o.pop(),h=c.root.$_componentId,m=a.randomId(),u=o.map(e=>(void 0===e&&n.fail(`${l}: undefined cannot be watched`,{template:s,loc:p}),a.isProp(e)&&n.fail(`${l}: Do not watch $props. Each component has its own Proxy so the child will not get the update. Instead watch the item in the parent, and re-render the child component`,{template:s,loc:p}),"object"==typeof e?`${e.ReBarsPath}.*`:e)),f=e.components.instances[h].renders;if(!u.length){const e=d.create(t.createFrame(c.root));r(e)}return u.forEach(e=>{a.hasKey(c.root,e)||n.fail(`${l}: cannot find path "${e}" to watch`,{template:s,loc:p})}),f[m]={path:u,render:()=>r(this)},a.dom.wrapWatcher(m,r(this),i)})),t.registerHelper("method",(function(){const[e,...o]=arguments,[r,d="click"]=e.split(":"),{data:c,loc:p}=o.pop();r in i||"$emit"===r||n.fail(`${l}: "${r}" is not a method`,{template:s,loc:p});const h={"data-rbs-method":[c.root.$_componentId,d,r]};return o&&o.length&&(h["data-rbs-method"]=h["data-rbs-method"].concat(o)),new t.SafeString(a.dom.propStr(h))})),t.registerHelper("bound",(e,{hash:o={},data:r,loc:d})=>{const i=[r.root.$_componentId,e];a.hasKey(r.root,e)||n.fail(`${l}: does not have path "${e}"`,{template:s,loc:d});const c={value:a.getKey(r.root,e),ref:o.ref||e,"data-rbs-bound":i};return new t.SafeString(a.dom.propStr(c))})}};function i(e,t){const n=new RegExp(/data-rbs(.*?)="(.*?)"/g);return e.replace(n,"")===t.replace(n,"")}var l={canPatch:e=>e.children.length&&e.children.length>1&&Array.from(e.children).every(e=>e.getAttribute("ref")),hasChanged:(e,t)=>!i(e.innerHTML,t),compare({app:e,$target:t,html:n}){const o=a.dom.getShadow(n),r=Array.from(o.children);Array.from(t.children).forEach(e=>{const t=a.dom.findRef(o,e.getAttribute("ref"));t?i(t.innerHTML,e.innerHTML)||e.replaceWith(t.cloneNode(!0)):e.remove()}),r.forEach((e,n)=>{a.dom.findRef(t,e.getAttribute("ref"))||function(e,t,n=0){n>=e.children.length?e.appendChild(t):e.insertBefore(t,e.children[n])}(t,e.cloneNode(!0),n)}),r.forEach((e,n)=>{const o=t.children[n];o.getAttribute("ref")!==e.getAttribute("ref")&&o.replaceWith(e.cloneNode(!0))})}},c={paths({app:e,paths:t,renders:o,name:r}){Object.entries(o).filter(([e,n])=>t.some(e=>a.shouldRender(e,n.path))&&a.dom.findWatcher(e)).forEach(([t,o])=>{const d=a.dom.findWatcher(t),s=o.render(),i=a.dom.recordState(d);if(l.hasChanged(d,s))return l.canPatch(d)?(l.compare({app:e,$target:d,html:s}),n.log(`${r}: patching ${o.path}`,d),void a.dom.restoreState(d,i)):(o.path.find(e=>e.endsWith(".length"))&&n.warn(`${r}: patching "${o.path}" add a ref="someUniqueKey" to each to avoid re-rendering the entire Array of elements`,d),d.style.display=""===s?"none":"",d.innerHTML=s,a.dom.restoreState(d,i),void n.log(`${r}: re-rendering watch block for ${o.path}`,d))}),e.deleteOrphans()}};const p=["component","ref","debug","isComponent","method","bound","watch","isComponent"];var h={register:function e({id:t,Handlebars:o,trace:i,helpers:l,components:h},{name:m,template:u,data:f=(()=>({})),helpers:g={},hooks:b={},methods:y={},watchers:$={},components:w=[]}){const v=arguments[0];m||n.fail("Every ReBars component should have a name!",v),"function"!=typeof f&&n.fail(`${m}: component data must be a function`,v),"string"!=typeof u&&n.fail("`${name}: needs a template string`",v);const A=arguments[0],E=o.create(),S=E.compile(u),T=w.reduce((t,n)=>{const o=e(A,n);return t[n.name]=o,t},{...h.registered});return Object.keys(f()).forEach(e=>{p.concat(Object.keys(g)).includes(e)&&n.fail(`${m}: cannot use "${e}" in your data as it's defined as a helper`,v)}),s.register({app:A,methods:y,instance:E,name:m,helpers:{...g,...l},components:T,template:u}),{instance(e={}){const t=a.randomId(),o=f(),s={},i=Object.entries(e).reduce((t,[n,o])=>(n.startsWith(r.listenerPrefix)&&(t[n.replace(r.listenerPrefix,"")]=o,e[n].delete),t),{}),l=d.create({...o,$props:e,$methods:y,$listeners:i,$emit:(e,t={})=>{i[e]&&i[e](t)},$name:m,$_componentId:t,$el:()=>a.dom.findComponent(t),$refs:()=>a.dom.findRefs(t)},e=>{n.log(`${m}: data changed "${e}"`,s),Object.entries($).reduce((t,[n,o])=>(e.some(e=>a.shouldRender(e,n.split(",")))&&t.push(o),t),[]).forEach(e=>e.call(l)),c.paths({app:A,paths:e,renders:s,name:m})});b.created&&b.created.call(l);const p={id:t,scope:l,hooks:b,renders:s,handlers:{bound(e){const[t,n]=e.currentTarget.dataset.rbsBound.split(",");a.setKey(l,n,e.target.value)},method(e){const[t,n,o,...a]=e.currentTarget.dataset.rbsMethod.split(",");"$emit"===o?l.$emit(a[0],l[a[0]]):l.$methods[o](e,...a)}},detached(){b.detached&&b.detached.call(l)},attached(){b.attached&&b.attached.call(l)},render:()=>a.dom.tagComponent(t,S(l),m)};return A.components.instances[t]=p,p}}}},m={app({$el:e,root:t,Handlebars:o=window.Handlebars,helpers:r={},components:d=[],trace:s=!1}){o||n.fail("noHbs"),document.body.contains(e)||n.fail("$el passed to ReBars app is either undefined or not present in the document."),window.ReBars=window.ReBars||{},window.ReBars.trace=s;const i={id:a.randomId(),Handlebars:o,trace:s,helpers:r,$el:e,deleteOrphans:a.debounce(()=>{Object.keys(i.components.instances).forEach(e=>{a.dom.findComponent(e)||delete i.components.instances[e]})}),components:{registered:{},instances:{}}};function l(e,t){const n="add"===e?"attached":"detached",o=t.dataset.rbsComp;i.components.instances[o][n]()}function c(e,t){const n="add"===e?"addEventListener":"removeEventListener",[o,a]=t.dataset.rbsMethod.split(",");t[n](a,i.components.instances[o].handlers.method)}function p(e,t){const n="add"===e?"addEventListener":"removeEventListener",[o,a]=t.dataset.rbsBound.split(",");t[n]("input",i.components.instances[o].handlers.bound)}return i.components.registered=d.reduce((e,t)=>(e[t.name]=h.register(i,t),e),{}),new MutationObserver(e=>{e.forEach(({addedNodes:e,removedNodes:t})=>{e.forEach(e=>{e.nodeType!==Node.TEXT_NODE&&(e.dataset.rbsComp&&l("add",e),e.dataset.rbsMethod&&c("add",e),e.dataset.rbsBound&&p("add",e),e.querySelectorAll("[data-rbs-comp]").forEach(l.bind(null,"add")),e.querySelectorAll("[data-rbs-method]").forEach(c.bind(null,"add")),e.querySelectorAll("[data-rbs-bound]").forEach(p.bind(null,"add")))}),t.forEach(e=>{e.nodeType!==Node.TEXT_NODE&&(e.dataset.rbsMethod&&c("remove",e),e.dataset.rbsBound&&p("remove",e),e.dataset.rbsComp&&l("remove",e),e.querySelectorAll("[data-rbs-method]").forEach(c.bind(null,"remove")),e.querySelectorAll("[data-rbs-bound]").forEach(p.bind(null,"remove")),e.querySelectorAll("[data-rbs-comp]").forEach(l.bind(null,"remove")))})})}).observe(e,{childList:!0,attributes:!0,subtree:!0}),e.innerHTML=h.register(i,t).instance().render(),i}},u={template:'\n  <div>\n    <div class="header-container">\n      <h1>\n        {{#watch header }}\n          <span>{{ header.title }}</span>\n          <small>{{ header.description }}</small>\n        {{/watch}}\n      </h1>\n\n      <label>\n        Title:\n        <input type="text" {{ bound "header.title" }}/>\n      </label>\n\n      <label>\n        Description:\n        <input type="text" {{ bound "header.description" }}/>\n      </label>\n    </div>\n\n    <ul class="simple">\n      {{#watch "todos.*" }}\n        {{#each todos }}\n          <li ref="{{ id }}">\n            <div class="todo">\n              <label>\n                <input type="checkbox" {{ isChecked done }} {{ method "toggleDone" id }} />\n                {{#if done }}\n                  <s>{{ name }}</s>\n                {{else}}\n                  <strong>{{ name }}</strong>\n                {{/if}}\n              </label>\n\n              <div class="actions">\n                <button {{ method "deleteTodo" id }}>delete</button>\n              </div>\n            </div>\n          </li>\n        {{/each}}\n      {{/watch}}\n    </ul>\n\n    {{#watch "adding" }}\n      {{#if adding }}\n        <form>\n          <input type="text" name="name" ref="newName" placeholder="the new todo" />\n          <button class="push" {{ method "addItem" }}>Add todo</button>\n          <button class="cancel" {{ method "toggleCreate" }}>Cancel</button>\n        </form>\n      {{else}}\n        <button class="add" {{ method "toggleCreate" }}>Add another</button>\n      {{/if}}\n    {{/watch}}\n  </div>\n  ',data:()=>({adding:!1,header:{title:"Todos",description:"some things that need done"},todos:[{done:!1,name:"Grocery Shopping",id:22},{done:!0,name:"Paint the House",id:44}]}),name:"DemoApp",helpers:{isChecked:e=>e?"checked":""},methods:{addItem(e){e.preventDefault();const t=this.$refs().newName;this.todos.push({id:(new Date).getTime(),name:t.value}),t.value=""},deleteTodo(e,t){const n=this.todos.findIndex(e=>e.id===t);this.todos.splice(n,1)},toggleDone(e,t){const n=this.todos.find(e=>e.id===t);n.done=!n.done},toggleCreate(e){e.preventDefault(),this.adding=!this.adding}}},f={template:'\n  <div>\n    <div class="header-container">\n      {{#watch "header.*" tag="h1" }}\n        <span>{{ header.title }}</span>\n        <small>{{ header.description }}</small>\n      {{/watch}}\n\n      <label>\n        Title:\n        <input type="text" {{ bound "header.title" }}/>\n      </label>\n\n      <label>\n        Description:\n        <input type="text" {{ bound "header.description" }}/>\n      </label>\n    </div>\n\n    {{#watch filters }}\n      {{ component "filters" filters=filters }}\n    {{/watch}}\n\n    {{#watch "filters.*" "todos.*" tag="ul"}}\n      {{#each filteredTodos as | todo | }}\n        <li ref="{{ todo.id }}">\n          {{\n            component "Todo"\n            todo=todo\n            index=@index\n            deleteTodo=@root.$methods.deleteTodo\n          }}\n        </li>\n      {{/each}}\n    {{/watch}}\n\n    {{\n      component "AddTodo"\n      addTodo=$methods.addTodo\n    }}\n  <div>\n  ',name:"DemoApp",data:()=>({filteredTodos(){let e=this.todos.concat();"incomplete"===this.filters.state?e=this.todos.filter(e=>!e.done):"completed"===this.filters.state&&(e=this.todos.filter(e=>e.done));const t=e.sort((e,t)=>"name"===this.filters.sortBy?e.name.localeCompare(t.name):new Date(e.updated).getTime()-new Date(t.updated).getTime());return"asc"===this.filters.sortDir?t:t.reverse()},filters:{state:null,sortBy:"name",sortDir:"asc"},header:{title:"ReBars Todos",description:"Some things that need done"},todos:[{done:!1,name:"Wash the car",updated:"3/1/2020, 12:37:10 PM",id:21},{done:!0,name:"Shopping for groceries",updated:"2/27/2020, 2:37:10 PM",id:22},{done:!1,name:"Code some Javascript",updated:"1/27/2020, 9:37:10 AM",id:23},{done:!0,name:"Go for a run",updated:"1/15/2020, 10:37:10 PM",id:24}]}),components:[{template:'\n  <div>\n    {{#watch "isAdding" }}\n      {{#if isAdding }}\n        <form>\n          {{#watch "newName" }}\n            <h3>{{ newName }}</h3>\n            <input type="text" {{ bound "newName" }} placeholder="the new todo" />\n          {{/watch}}\n\n          <button class="push" {{ method "addItem" }}>Add todo</button>\n          <button class="cancel" {{ method "toggleAdd" }}>Cancel</button>\n        </form>\n      {{ else }}\n        <button class="add" {{ method "toggleAdd" }}>Add another</button>\n      {{/if}}\n    {{/watch}}\n  </div>\n  ',name:"AddTodo",data:()=>({isAdding:!1,hasError:!1,newName:""}),methods:{toggleAdd(e){e.preventDefault(),this.isAdding=!this.isAdding},addItem(e){e.preventDefault(),this.$props.addTodo(this.newName),this.newName=""}}},{template:'\n    <div>\n      {{#watch "editing" tag="div" class="todo" }}\n        {{#if editing}}\n          <input type="text" value="{{ $props.todo.name }}" ref="nameInput"/>\n          <button {{ method "save" }}>save</button>\n        {{ else }}\n          <label>\n            <input type="checkbox" {{ isChecked $props.todo.done }} {{ method "toggleDone" }} />\n            {{#if $props.todo.done }}\n              <s>{{ $props.todo.name }}</s>\n            {{else}}\n              <strong>{{ $props.todo.name }}</strong>\n            {{/if}}\n          </label>\n\n          <div class="actions">\n            <span class="date">{{ timeAgo todo.updated }}</span>\n            <button {{ method "remove" }}>delete</button>\n            <button {{ method "toggleEditing" }}>edit</button>\n          </div>\n        {{/if}}\n      {{/watch}}\n    </div>\n  ',name:"Todo",data:()=>({editing:!1}),helpers:{isChecked:e=>e?"checked":"",timeAgo:e=>window.moment(e).fromNow()},methods:{save(){this.$props.todo.name=this.$refs().nameInput.value,this.$props.todo.updated=(new Date).toLocaleString(),this.editing=!1},remove(){this.$props.deleteTodo(this.$props.todo.id)},toggleEditing(){this.editing=!this.editing},toggleDone(){this.$props.todo.done=!this.$props.todo.done}}},{template:'\n    <div class="filters">\n      <div>\n        <button {{ disabledIf "completed" }} {{ method "filterBy" "completed" }}>Show Completed</button>\n        <button {{ disabledIf "incomplete" }} {{ method "filterBy" "incomplete" }}>Show Incompleted</button>\n        <button {{ disabledIf null }} {{ method "filterBy" null }}>Show All</button>\n      </div>\n\n      <div>\n        <select {{ bound "$props.filters.sortBy" }}>\n          <option {{ selectedIf $props.filters.sortBy "name" }} value="name">Sort by Name</option>\n          <option {{ selectedIf $props.filters.sortBy "updated" }} value="updated">Sort by Updated at</option>\n        </select>\n\n        <select {{ bound "$props.filters.sortDir" }}>\n          <option {{ selectedIf $props.filters.sortDir "asc" }} value="asc">Ascending</option>\n          <option {{ selectedIf $props.filters.sortDir "desc" }} value="desc">Descending</option>\n        </select>\n      </div>\n    </div>\n  ',name:"filters",helpers:{selectedIf:(e,t)=>e===t?"selected":"",disabledIf:(e,{data:t})=>t.root.$props.filters.state===e?"disabled":""},methods:{filterBy(e,t){this.$props.filters.state=t}}}],methods:{addTodo(e){this.todos.push({name:e,id:(new Date).getTime(),updated:(new Date).toLocaleString()}),this.filters.state=null},deleteTodo(e){const t=this.todos.findIndex(t=>t.id===e);this.todos.splice(t,1)},showAdd(e){e.preventDefault(),this.uiState.adding=!0}}},g={template:'\n    <h3>\n      Button have been clicked\n        {{#watch "clicked" }}\n          <span>{{ clicked }}</span>\n          Clicked {{ clicked }} times\n        {{/watch}}\n      <button {{ method "step" }}>Click Me</button>\n    </h3>\n  ',name:"counter",data:()=>({clicked:0}),methods:{step(){this.clicked++}}},b={template:'\n    <div>\n      {{#watch}}\n        <h2>{{ title }}</h2>\n        <input type="text" {{ bound "title" ref="title1" }}>\n        <input type="text" {{ bound "title" ref="title2" }}>\n      {{/watch}}\n    </div>\n  ',name:"bound",data:()=>({title:"Hi, I am bound"})};window.Prism=window.Prism||{},window.Prism.manual=!0,m.app({$el:document.getElementById("demo-app-simple"),root:u}),m.app({$el:document.getElementById("demo-app-advanced"),root:f}),m.app({$el:document.getElementById("counter-demo"),root:g}),m.app({$el:document.getElementById("bound-demo"),root:b}),document.querySelectorAll(".language-html").forEach(e=>{e.innerText.includes("<script src")||(e.classList.remove("language-html"),e.classList.add("language-handlebars"))}),Prism.highlightAll(),Array.from(document.querySelectorAll("code.language-javascript .token.string")).filter(e=>e.innerText.trim().startsWith("<")&&e.innerText.trim().endsWith(">")).forEach(e=>{e.innerHTML=Prism.highlight(e.innerText,Prism.languages.handlebars,"handlebars")}),document.querySelectorAll("nav.tabs button").forEach(e=>{const t=e.parentElement.querySelectorAll("*"),n=e.parentElement.parentElement.querySelectorAll(".tab-content *");e.addEventListener("click",o=>{o.preventDefault(),t.forEach(e=>e.classList.remove("active")),n.forEach(e=>e.classList.remove("active")),e.classList.add("active"),document.getElementById(e.dataset.target).classList.add("active")})}),function(){const e=new IntersectionObserver(e=>{e.forEach(e=>{const t=e.target.getAttribute("id")||e.target.dataset.anchor,n=document.querySelector(`.side-bar-nav a[href="#${t}"]`);n&&(e.intersectionRatio>0?n.classList.add("active"):n.classList.remove("active"))})});document.querySelectorAll(" h1[id],h2[id],div[id],div[data-anchor]").forEach(t=>{e.observe(t)})}();
