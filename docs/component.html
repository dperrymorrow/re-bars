<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>ReBars Docs: Introduction</title>
    <link rel="stylesheet" href="css/index.css">

    <script src="//cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.5.3/handlebars.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/prismjs@1.19.0/prism.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/prismjs@1.19.0/components/prism-markup-templating.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/prismjs@1.19.0/components/prism-handlebars.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/marked/0.8.1/marked.min.js"></script>
  </head>

  <body>

    <main>
      <nav id="nav-container">

        <div class="logo">ReBars</div>


      </nav>
      <section>
        <div class="content">
          <div class="markdown-content">
            <h1>ReBars Components</h1><p>Components are where everything happens. Each component has it&#39;s own <code>Handlebars.instance</code> so their helpers are isolated from other components/applications.</p>
<pre><code class="language-javascript">export default {
  template: /*html*/ `&lt;div&gt;&lt;/div&gt;`, // your Handlebars template
  name: &quot;myComponent&quot;, // must have a name
  data() { return {} }, // data for your template
  methods: {}, // event handlers
  hooks: {}, // lifecycle hooks
  watchers: {}, // methods to fire on change of data
  helpers: {} // Handlebars helpers just for this component
}</code></pre>
<h2>Template</h2><p>The template is the Handlebars template that will be rendered. What is defined as the return from your <code>data()</code> function will be the root scope of the template when rendering.</p>
<h2>Name</h2><p>Each component must define a name. This is is the string you will use to render components using the <a href="helpers.html#the-component-helper">component</a> helper within your template.</p>
<h2>Data</h2><p>The data for the component. Must be a function that retuns an Object.</p>
<pre><code class="language-javascript">data() {
  return {
    name: {
      first: &quot;David&quot;,
      last: &quot;Morrow&quot;
    }
  }
}</code></pre>
<blockquote>
<p>It is also possible to return a function as a key in your data. This can be very useful.</p>
</blockquote>
<pre><code class="language-javascript">data() {
  return {
    fullName() {
      return `${this.name.first}, ${this.name.last}`;
    },
    name: {
      first: &quot;David&quot;,
      last: &quot;Morrow&quot;
    }
  }
}</code></pre>
<pre><code class="language-html">&lt;p&gt;{{ fullName }}&lt;/p&gt;</code></pre>
<h2>Methods</h2><p>Methods defined in a component are avalable for use with the <a href="helpers.html#method">method</a> helper, or can be called from within another method.</p>
<pre><code class="language-html">&lt;button {{ method &quot;save:click&quot; &quot;fred&quot; }}&gt;save&lt;/button&gt;</code></pre>
<pre><code class="language-javascript">methods: {
  save(event, name) {
    // this.$methods
    // this.$refs()
    // this.$props
  }
}</code></pre>
<blockquote>
<p>Methods can reference other methods.</p>
</blockquote>
<pre><code class="language-javascript">methods: {
  findFriend(name) {
    this.friends.find(friend =&gt; friend.name === name);
  },
  save(event, name) {
    const friend = this.$methods.findFriend(name);
    // save your friend
  }
}</code></pre>
<h2>Watchers</h2><p>Watchers give you the ability to fire <em>&quot;hooks&quot;</em> when a property in your data has change. You can watch any items in  your data or <code>$props</code></p>
<blockquote>
<p>You cannot, however watch a method in your data. Methods defined in your data are only for convienance for your template rendering.</p>
</blockquote>
<pre><code class="language-javascript">data() {
  return {
    name: {
      first: &quot;david&quot;
    }
  };
},

watchers: {
  &quot;name.first&quot;() {
    console.log(this.name.first); // david
    // this.$refs()
    // this.$methods
    // this.$props
  }
}</code></pre>
<p>Each time <code>name.first</code> is changed the method will be triggered with the same context you would have in a method.</p>
<h2>Hooks</h2><p>Hooks are triggered at different points in the component instance&#39;s life.</p>
<ul>
<li><code>created</code> triggered when the component is instantiated and prior to rendering</li>
<li><code>attached</code> the component has been rendered and added to the DOM</li>
<li><code>teardown</code> the component is about to be deleted, but at this point is still on the DOM</li>
</ul>
<blockquote>
<p><code>this.$refs()</code> cannot be used in the created hook. The component is not yet on the DOM. If you need to do something with the component&#39;s <code>$refs</code> or DOM. Use the attached hook instead.</p>
</blockquote>
<pre><code class="language-javascript">data() {
  return {
    name: {
      first: &quot;David&quot;
    }
  }
},

hooks: {
  created() {
    // you can set items here pre render
    this.name.first = &quot;Mike&quot;;
  }
}</code></pre>
<h2>Helpers</h2><p>Any methods you define under Handlebars helpers methods you define in <code>helpers</code> will be automatically added to the instance rendering the component, and be available for use. ReBars includes several <a href="helpers.html">helpers</a> as well.</p>
<pre><code class="language-html">&lt;input type=&quot;checkbox&quot; {{ isChecked someBoolean }} /&gt;</code></pre>
<pre><code class="language-javascript">helpers: {
  isChecked: val =&gt; (val ? &quot;checked&quot; : &quot;&quot;),
}</code></pre>
<p>These helpers are only available for the context of the component you are defining. If you would like to define helpers that are global. Add them to the <a href="application.html">ReBars application</a>.</p>
          </div>
        </div>
      </section>
    </main>
    
    <script src="js/index.js"></script>
  </body>
</html>
